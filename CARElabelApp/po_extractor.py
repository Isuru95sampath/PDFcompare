"""
PO Extractor Module
==================

This module contains all functions for extracting data from merged PO PDFs.
It's designed to work with POs generated by Email ‚Üí PDF Merger function.
"""

import streamlit as st
import re
import pdfplumber
import pandas as pd
from typing import List, Dict, Any, Optional

# =============================================================================
# MAIN EXTRACTION FUNCTIONS
# =============================================================================

def extract_merged_po_details(pdf_file) -> List[Dict[str, Any]]:
    """
    Extract details from merged PO PDFs (output from Email ‚Üí PDF Merger)
    
    Args:
        pdf_file: A file-like object (e.g., from st.file_uploader)
    
    Returns:
        List of dictionaries with PO details
    """
    po_list = []
    
    try:
        with pdfplumber.open(pdf_file) as pdf:
            # Skip the first page (email content) and process the rest
            for page_num in range(1, len(pdf.pages)):
                page = pdf.pages[page_num]
                text = page.extract_text() or ""
                
                # Check if this page contains PO information
                if "Purchase Order" in text and "PO No." in text:
                    # Extract PO number (without BFF prefix)
                    po_number = extract_po_number(text)
                    
                    # Extract supplier information
                    supplier_info = extract_supplier_info(text)
                    
                    # Extract items from the table
                    items = extract_po_items_enhanced(text)
                    
                    # Extract additional PO details
                    po_details = extract_additional_po_details(text)
                    
                    # Calculate total quantity
                    total_quantity = sum(safe_float_conversion(item['quantity']) for item in items if is_number(item['quantity']))
                    
                    po_list.append({
                        'po_number': po_number,
                        'supplier': supplier_info['supplier'],
                        'address': supplier_info['address'],
                        'items': items,
                        'total_quantity': safe_int_conversion(total_quantity),
                        **po_details
                    })
    
    except Exception as e:
        st.error(f"Error extracting PO details: {str(e)}")
        return []
    
    return po_list

def extract_po_number(text: str) -> str:
    """
    Extract PO number from PO text (without BFF prefix)
    
    Args:
        text: Text content from PO page
    
    Returns:
        PO number as string
    """
    po_match = re.search(r'BFF\s+(\d+)', text)
    return po_match.group(1) if po_match else ""

def extract_supplier_info(text: str) -> Dict[str, str]:
    """
    Extract supplier information from PO text
    
    Args:
        text: Text content from PO page
    
    Returns:
        Dictionary with supplier details
    """
    supplier_info = {
        'supplier': '',
        'address': '',
        'attention': '',
        'vat_reg_no': '',
        'business_reg_no': '',
        'telephone': '',
        'email': ''
    }
    
    # Extract attention (contact person)
    attention_match = re.search(r'Attention\s*:\s*(.*?)\n', text)
    if attention_match:
        supplier_info['attention'] = attention_match.group(1).strip()
    
    # Extract supplier name - only the first line after "Supplier:"
    supplier_match = re.search(r'Supplier\s*:\s*(.*?)(?:\n|$)', text)
    if supplier_match:
        supplier_name = supplier_match.group(1).strip()
        # Remove any text after "Printout Date" or other non-supplier info
        # Stop at common field indicators
        stop_words = ['Printout Date', 'Requested By', 'Approver', 'PO No', 'Date']
        for word in stop_words:
            if word in supplier_name:
                supplier_name = supplier_name.split(word)[0].strip()
        supplier_info['supplier'] = supplier_name
    
    # Extract address (multi-line) - stop before Delivery Terms
    address_match = re.search(r'Supplier Address\s*:\s*(.*?)(?=\n(?:Delivery Terms|Payment Terms|Currency|$))', text, re.DOTALL)
    if address_match:
        address = address_match.group(1).strip()
        # Clean up the address - remove line breaks and extra spaces
        address = re.sub(r'\s+', ' ', address)
        # Remove any "Printout Date" or similar fields if they leaked in
        if 'Printout Date' in address:
            address = address.split('Printout Date')[0].strip()
        supplier_info['address'] = address
    
    # Extract VAT Registration Number
    vat_match = re.search(r'VAT Reg\.?\s*No\.?\s*:\s*(.*?)\n', text)
    if vat_match:
        supplier_info['vat_reg_no'] = vat_match.group(1).strip()
    
    # Extract Business Registration Number
    business_match = re.search(r'Business\s*Rg\.?\s*No\.?\s*:\s*(.*?)\n', text)
    if business_match:
        supplier_info['business_reg_no'] = business_match.group(1).strip()
    
    # Extract Telephone
    telephone_match = re.search(r'T\.?\s*Phone\s*/?\s*Telefax\s*:\s*(.*?)\n', text)
    if telephone_match:
        supplier_info['telephone'] = telephone_match.group(1).strip()
    
    # Extract Email
    email_match = re.search(r'E\s*Mail\s*:\s*(.*?)\n', text)
    if email_match:
        supplier_info['email'] = email_match.group(1).strip()
    
    return supplier_info

def extract_po_items_enhanced(text: str) -> List[Dict[str, str]]:
    """
    Enhanced extraction of items (size and quantity) from PO text
    
    Args:
        text: Text content from PO page
    
    Returns:
        List of dictionaries with item details
    """
    items = []
    
    # Split text into lines
    lines = text.split('\n')
    
    # Find the start of the item table
    table_start = find_table_start(lines)
    
    if table_start == -1:
        return items
    
    # Process lines after the table header
    i = table_start + 1
    while i < len(lines):
        line = lines[i].strip()
        
        # Check if this is an item line (starts with a number)
        if re.match(r'^\d+\s+', line):
            # Extract item details
            item = extract_item_details(lines, i)
            if item:
                items.append(item)
                # Skip the next line if it contains size info
                if i + 1 < len(lines) and "Color/Size/Destination" in lines[i + 1]:
                    i += 1
        
        i += 1
    
    return items

def find_table_start(lines: List[str]) -> int:
    """
    Find starting line of the item table
    
    Args:
        lines: List of text lines
    
    Returns:
        Index of the table start line
    """
    for i, line in enumerate(lines):
        if "No Item Quantity" in line or ("No Item" in line and "Quantity" in line):
            return i
    return -1

def extract_item_details(lines: List[str], line_index: int) -> Optional[Dict[str, str]]:
    """
    Extract details from a single item line
    
    Args:
        lines: List of text lines
        line_index: Index of the current item line
    
    Returns:
        Dictionary with item details or None if not found
    """
    line = lines[line_index].strip()
    
    # Extract quantity from this line
    qty_match = re.search(r'([\d,]+\.\d+)', line)
    if not qty_match:
        return None
    
    quantity = qty_match.group(1).replace(',', '')
    
    # Extract item description
    desc_match = re.search(r'\d+\s+(.*?)\s+([\d,]+\.\d+)', line)
    description = desc_match.group(1).strip() if desc_match else ""
    
    # Extract product code from description (between "LBL.CARE_" and "-MWC")
    product_code = extract_product_code(description)
    
    # Extract unit price and line amount
    price_match = re.search(r'([\d,]+\.\d+)\s+([\d,]+\.\d+)', line)
    unit_price = price_match.group(1) if price_match else ""
    line_amount = price_match.group(2) if price_match else ""
    
    # Extract size and other details from the next line
    size_info = extract_size_and_details_from_next_line(lines, line_index)
    
    return {
        'description': description,
        'product_code': product_code,
        'quantity': quantity,
        'unit_price': unit_price,
        'line_amount': line_amount,
        'size': size_info['size'],
        'color_size_destination': size_info['full_details'],
        'others': size_info['others']
    }

def extract_product_code(description: str) -> str:
    """
    Extract product code from item description
    Between "LBL.CARE_" and "-MWC"
    
    Args:
        description: Item description text
    
    Returns:
        Product code as string
    """
    # Pattern to match product code after "LBL.CARE_" and before "-MWC"
    # Example: "LBL.CARE_LB 5801-MWC015" -> "LB 5801"
    code_match = re.search(r'LBL\.CARE_(.*?)(?:-MWC|$)', description)
    if code_match:
        return code_match.group(1).strip()
    
    return ""

def extract_size_and_details_from_next_line(lines: List[str], line_index: int) -> Dict[str, str]:
    """
    Extract size and full details from the line following an item
    
    Args:
        lines: List of text lines
        line_index: Index of the current item line
    
    Returns:
        Dictionary with size, full details, and others
    """
    result = {
        'size': '',
        'full_details': '',
        'others': ''
    }
    
    if line_index + 1 >= len(lines):
        return result
    
    next_line = lines[line_index + 1].strip()
    if "Color/Size/Destination" not in next_line:
        return result
    
    # Extract everything after "Color/Size/Destination :"
    details_match = re.search(r'Color/Size/Destination\s*:\s*(.*)', next_line)
    if details_match:
        full_details = details_match.group(1).strip()
        result['full_details'] = full_details
        
        # Known sizes to look for in the extracted details
        known_sizes = ['XXXL', 'XXL', 'XL', 'L', 'M', 'S', 'XS']
        
        # Look for size patterns in the full details
        for size in known_sizes:
            # Check if size appears as a separate word
            if re.search(r'\b' + size + r'\b', full_details):
                result['size'] = size
                break
        
        # Extract "others" - everything after "/"
        others_match = re.search(r'/(.*)', full_details)
        if others_match:
            result['others'] = others_match.group(1).strip()
    
    return result

def extract_additional_po_details(text: str) -> Dict[str, str]:
    """
    Extract additional PO details like dates, terms, etc.
    
    Args:
        text: Text content from PO page
    
    Returns:
        Dictionary with additional PO details
    """
    details = {}
    
    # Extract Delivery Location Forwarder
    forwarder_match = re.search(r'Delivery Location Forwarder:\s*(.*?)\n', text)
    if forwarder_match:
        details['delivery_forwarder'] = forwarder_match.group(1).strip()
    
    # Extract Payment Terms
    payment_terms_match = re.search(r'Payment Terms:\s*(.*?)\n', text)
    if payment_terms_match:
        details['payment_terms'] = payment_terms_match.group(1).strip()
    
    # Extract Packaging Terms
    packaging_terms_match = re.search(r'Packaging Terms:\s*(.*?)\n', text)
    if packaging_terms_match:
        details['packaging_terms'] = packaging_terms_match.group(1).strip()
    
    # Extract Delivery Location (at the bottom of the PO)
    delivery_location = extract_delivery_location(text)
    details['delivery_location'] = delivery_location  # Always include, even if empty
    
    return details

def extract_delivery_location(text: str) -> str:
    """
    Extract delivery location from the bottom of the PO
    
    Args:
        text: Text content from PO page
    
    Returns:
        Delivery location as string
    """
    # Try multiple patterns to find the delivery location
    
    # Pattern 1: "Delivery Location:" followed by text until "This is an automated PO."
    delivery_location_match = re.search(r'Delivery Location\s*:\s*\n(.*?)(?=This is an automated PO\.)', text, re.DOTALL)
    
    if delivery_location_match:
        location_text = delivery_location_match.group(1).strip()
    else:
        # Pattern 2: "Delivery Location:" followed by text until end of document
        delivery_location_match = re.search(r'Delivery Location\s*:\s*\n(.*)', text, re.DOTALL)
        
        if delivery_location_match:
            location_text = delivery_location_match.group(1).strip()
            # Remove "This is an automated PO." if present
            location_text = re.sub(r'This is an automated PO\..*$', '', location_text, flags=re.DOTALL).strip()
        else:
            # Pattern 3: "Delivery Location" (without colon) followed by text
            delivery_location_match = re.search(r'Delivery Location\s*\n(.*?)(?=This is an automated PO\.)', text, re.DOTALL)
            
            if delivery_location_match:
                location_text = delivery_location_match.group(1).strip()
            else:
                # Pattern 4: Look for any occurrence of "Delivery Location" and extract following lines
                lines = text.split('\n')
                location_text = ""
                found_delivery_location = False
                
                for i, line in enumerate(lines):
                    if "Delivery Location" in line:
                        found_delivery_location = True
                        # Skip this line and extract following lines
                        for j in range(i + 1, len(lines)):
                            if "This is an automated PO." in lines[j]:
                                break
                            if lines[j].strip():  # Only add non-empty lines
                                if location_text:
                                    location_text += "\n"
                                location_text += lines[j].strip()
                        break
                
                if not found_delivery_location:
                    return ""
    
    # Clean up the extracted text
    if location_text:
        # Remove excessive spaces (5 or more consecutive spaces)
        location_text = re.sub(r'\s{5,}', ' ', location_text)
        
        # Clean up any extra whitespace
        location_text = re.sub(r'\n+', '\n', location_text)
        location_text = location_text.strip()
        
        return location_text
    
    return ""

# =============================================================================
# HELPER FUNCTIONS FOR SAFE CONVERSION
# =============================================================================

def is_number(s):
    """Check if a string can be converted to a number"""
    try:
        float(s)
        return True
    except (ValueError, TypeError):
        return False

def safe_float_conversion(value):
    """Safely convert a string to float"""
    try:
        return float(str(value).replace(',', ''))
    except (ValueError, TypeError):
        return 0.0

def safe_int_conversion(value):
    """Safely convert a float to int"""
    try:
        return int(value)
    except (ValueError, TypeError):
        return 0

# =============================================================================
# DATA PROCESSING FUNCTIONS
# =============================================================================

def process_po_data(po_list: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Process and aggregate PO data
    
    Args:
        po_list: List of PO dictionaries
    
    Returns:
        Dictionary with processed data
    """
    processed = {
        'total_pos': len(po_list),
        'total_items': sum(len(po['items']) for po in po_list),
        'total_quantity': 0,
        'suppliers': list(set(po['supplier'] for po in po_list if po['supplier'])),
        'size_breakdown': {},
        'po_summary': []
    }
    
    # Calculate size breakdown and total quantity
    for po in po_list:
        for item in po['items']:
            size = item['size']
            quantity = safe_int_conversion(safe_float_conversion(item['quantity']))
            
            # Add to total quantity
            processed['total_quantity'] += quantity
            
            # Add to size breakdown
            if size in processed['size_breakdown']:
                processed['size_breakdown'][size] += quantity
            else:
                processed['size_breakdown'][size] = quantity
    
    # Create PO summary
    for po in po_list:
        processed['po_summary'].append({
            'po_number': po['po_number'],
            'supplier': po['supplier'],
            'total_quantity': safe_int_conversion(safe_float_conversion(po['total_quantity'])),
            'number_of_items': len(po['items']),
            'delivery_forwarder': po.get('delivery_forwarder', ''),
            'payment_terms': po.get('payment_terms', ''),
            'packaging_terms': po.get('packaging_terms', ''),
            'delivery_location': po.get('delivery_location', '')
        })
    
    return processed

def create_detailed_table(po_list: List[Dict[str, Any]]) -> pd.DataFrame:
    """
    Create a detailed table with all PO information
    
    Args:
        po_list: List of PO dictionaries
    
    Returns:
        DataFrame with detailed PO information
    """
    table_data = []
    
    for po in po_list:
        if po['items']:
            for item in po['items']:
                table_data.append({
                    'PO Number': po['po_number'],
                    'Supplier': po['supplier'],
                    'Address': po['address'],
                    'Description': item['description'],
                    'Product Code': item.get('product_code', ''),
                    'Size': item['size'],
                    'Quantity': safe_int_conversion(safe_float_conversion(item['quantity'])),
                    'Unit Price': item['unit_price'],
                    'Line Amount': item['line_amount'],
                    'Color/Size/Destination': item.get('color_size_destination', ''),
                    'Others': item.get('others', ''),
                    'Delivery Location': po.get('delivery_location', ''),
                    'PO Total Quantity': safe_int_conversion(safe_float_conversion(po['total_quantity']))
                })
        else:
            # Add PO even if no items found
            table_data.append({
                'PO Number': po['po_number'],
                'Supplier': po['supplier'],
                'Address': po['address'],
                'Description': 'N/A',
                'Product Code': 'N/A',
                'Size': 'N/A',
                'Quantity': 0,
                'Unit Price': '0.00',
                'Line Amount': '0.00',
                'Color/Size/Destination': 'N/A',
                'Others': 'N/A',
                'Delivery Location': po.get('delivery_location', ''),
                'PO Total Quantity': safe_int_conversion(safe_float_conversion(po['total_quantity']))
            })
    
    return pd.DataFrame(table_data)

def create_summary_table(po_list: List[Dict[str, Any]]) -> pd.DataFrame:
    """
    Create a summary table with one row per PO
    
    Args:
        po_list: List of PO dictionaries
    
    Returns:
        DataFrame with PO summary
    """
    summary_data = []
    for po in po_list:
        summary_data.append({
            'PO Number': po['po_number'],
            'Supplier': po['supplier'],
            'Total Quantity': safe_int_conversion(safe_float_conversion(po['total_quantity'])),
            'Number of Items': len(po['items']),
            'Delivery Forwarder': po.get('delivery_forwarder', ''),
            'Payment Terms': po.get('payment_terms', ''),
            'Packaging Terms': po.get('packaging_terms', ''),
            'Delivery Location': po.get('delivery_location', '')
        })
    
    return pd.DataFrame(summary_data)

def create_size_breakdown_table(po_list: List[Dict[str, Any]]) -> pd.DataFrame:
    """
    Create a size breakdown table aggregating quantities by size
    
    Args:
        po_list: List of PO dictionaries
    
    Returns:
        DataFrame with size breakdown
    """
    size_data = {}
    for po in po_list:
        for item in po['items']:
            size = item['size']
            quantity = safe_int_conversion(safe_float_conversion(item['quantity']))
            if size in size_data:
                size_data[size] += quantity
            else:
                size_data[size] = quantity
    
    return pd.DataFrame([
        {'Size': size, 'Total Quantity': qty} 
        for size, qty in sorted(size_data.items())
    ])

# =============================================================================
# DISPLAY FUNCTIONS
# =============================================================================

def display_merged_po_results(po_list: List[Dict[str, Any]]):
    """
    Display the extracted PO information in a formatted way
    
    Args:
        po_list: List of PO dictionaries
    """
    if not po_list:
        st.warning("No PO details found in the uploaded PDF.")
        return
    
    st.success(f"Successfully extracted details from {len(po_list)} PO(s)")
    
    # Apply custom CSS for table formatting
    apply_table_styles()
    
    # Process data
    processed_data = process_po_data(po_list)
    
    # Display summary statistics
    display_summary_statistics(processed_data)
    
    # Display each PO in vertical format
    display_po_cards(po_list)
    
    # Display size breakdown
    display_size_breakdown(po_list)
    
    # Display download options
    display_download_options(po_list)

def apply_table_styles():
    """Apply custom CSS styles for tables"""
    st.markdown("""
    <style>
    /* Vertical table styling */
    .dataframe th {
        text-align: left !important;
        font-weight: bold;
        padding: 10px !important;
        background-color: #f8f9fa !important;
    }
    
    .dataframe td {
        padding: 10px !important;
        text-align: left !important;
    }
    
    /* PO Card styling */
    .po-card {
        background: white;
        border-radius: 8px;
        padding: 20px;
        margin: 20px 0;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .po-header {
        font-size: 20px;
        font-weight: bold;
        color: #1f77b4;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid #1f77b4;
    }
    
    div[data-testid="metric-container"] {
        text-align: left;
    }
    
    .dataframe {
        border-collapse: collapse;
    }
    
    .dataframe th, .dataframe td {
        border: 1px solid #ddd;
    }
    
    .delivery-location {
        white-space: pre-wrap;
        font-family: monospace;
        background-color: #f8f9fa;
        padding: 10px;
        border-radius: 4px;
        border: 1px solid #ddd;
        margin-top: 10px;
        margin-bottom: 10px;
    }
    
    .delivery-location-header {
        font-weight: bold;
        color: #1f77b4;
        margin-bottom: 5px;
    }
    
    .delivery-location-empty {
        color: #888;
        font-style: italic;
    }
    </style>
    """, unsafe_allow_html=True)

def display_summary_statistics(processed_data: Dict[str, Any]):
    """Display summary statistics in columns"""
    st.subheader("üìà Summary Statistics")
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric("Total POs", processed_data['total_pos'])
        st.metric("Suppliers", len(processed_data['suppliers']))
    
    with col2:
        st.metric("Total Items", processed_data['total_items'])
        st.metric("Total Quantity", processed_data['total_quantity'])
    
    with col3:
        if processed_data['suppliers']:
            st.write("**Suppliers:**")
            for supplier in processed_data['suppliers']:
                st.write(f"‚Ä¢ {supplier}")

def display_po_cards(po_list: List[Dict[str, Any]]):
    """Display each PO in a vertical card format like image"""
    st.subheader("üìã Purchase Order Details")
    
    for po_idx, po in enumerate(po_list, 1):
        # Create PO header
        st.markdown(f'<div class="po-card">', unsafe_allow_html=True)
        st.markdown(f'<div class="po-header">Purchase Order #{po["po_number"]}</div>', unsafe_allow_html=True)
        
        # PO General Information - Create DataFrame format with Field | Value columns
        general_data = []
        
        if po['supplier']:
            general_data.append({'Field': 'Supplier', 'Value': po['supplier']})
        
        if po['address']:
            general_data.append({'Field': 'Address', 'Value': po['address']})
        
        if po.get('delivery_forwarder'):
            general_data.append({'Field': 'Delivery Forwarder', 'Value': po['delivery_forwarder']})
        
        if po.get('payment_terms'):
            general_data.append({'Field': 'Payment Terms', 'Value': po['payment_terms']})
        
        if po.get('packaging_terms'):
            general_data.append({'Field': 'Packaging Terms', 'Value': po['packaging_terms']})
        
        # Add delivery location to the table
        delivery_loc = po.get('delivery_location', '')
        if delivery_loc:
            general_data.append({'Field': 'Delivery Location', 'Value': delivery_loc})
        else:
            general_data.append({'Field': 'Delivery Location', 'Value': 'No delivery location found'})
        
        # Display general info as a DataFrame with index showing row numbers
        if general_data:
            df_general = pd.DataFrame(general_data)
            st.dataframe(df_general, use_container_width=True, hide_index=False)
        
        # Items breakdown table - separate table
        if po['items']:
            st.markdown("**üì¶ Items Breakdown:**")
            
            items_data = []
            for item in po['items']:
                items_data.append({
                    'Product Code': item.get('product_code', 'N/A'),
                    'Size': item['size'] if item['size'] else 'N/A',
                    'Quantity': safe_int_conversion(safe_float_conversion(item['quantity'])),
                    'Unit Price': item['unit_price'],
                    'Line Amount': item['line_amount'],
                    'Color/Size/Destination': item.get('color_size_destination', 'N/A'),
                    'Others': item.get('others', 'N/A')
                })
            
            df_items = pd.DataFrame(items_data)
            st.dataframe(df_items, use_container_width=True, hide_index=True)
            
            # Total quantity summary
            st.markdown(f"**üìä Total Quantity: {po['total_quantity']}**")
        
        st.markdown('</div>', unsafe_allow_html=True)
        
        # Add spacing between POs
        if po_idx < len(po_list):
            st.markdown("<br>", unsafe_allow_html=True)

def display_merged_po_results(po_list: List[Dict[str, Any]]):
    """
    Display the extracted PO information in a formatted way
    
    Args:
        po_list: List of PO dictionaries
    """
    if not po_list:
        st.warning("No PO details found in the uploaded PDF.")
        return
    
    st.success(f"Successfully extracted details from {len(po_list)} PO(s)")
    
    # Apply custom CSS for table formatting
    apply_table_styles()
    
    # Process data
    processed_data = process_po_data(po_list)
    
    # Display summary statistics
    display_summary_statistics(processed_data)
    
    # Display each PO in vertical format
    display_po_cards(po_list)
    
    # Display download options
    display_download_options(po_list)

def display_download_options(po_list: List[Dict[str, Any]]):
    """Display download options for all data formats"""
    st.subheader("üíæ Download Options")
    
    col1, col2 = st.columns(2)  # Changed from 3 columns to 2
    
    with col1:
        # Download detailed table
        df = create_detailed_table(po_list)
        csv = df.to_csv(index=False).encode('utf-8')
        st.download_button(
            label="‚¨áÔ∏è Download Detailed PO Data",
            data=csv,
            file_name="po_detailed_data.csv",
            mime="text/csv"
        )
    
    with col2:
        # Download summary table
        df = create_summary_table(po_list)
        csv = df.to_csv(index=False).encode('utf-8')
        st.download_button(
            label="‚¨áÔ∏è Download PO Summary",
            data=csv,
            file_name="po_summary.csv",
            mime="text/csv"
        )